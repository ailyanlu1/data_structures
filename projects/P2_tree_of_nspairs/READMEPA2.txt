README FOR BLAKE CONRADbmconrad@iupui.eduI.”NSPAIR DATA STRUCTURE/CLASSMy NSPair class is built to have 2 main components a) an int, and b) a string.The class itself builds exactly what I need; my methods are not portable.I use constructors as a strong element to building this class, so as soon as you decide to make a NSPair object, it will be expected a very specific parameter for construction; So as soon as you build an NSPair object in the main.cpp, it will be expecting a data.txt file and that constructor will trigger everything else that needs to happen to accomplish getting the file stored as NSPair’s, QSorted, ISorted, timed, and stored into a new file in the current directory. II. “THE ALGORITHM YOU USED FOR QSORT”My algorithm is modeled after the “divide and conquer” technique that utilizes an insertion sort in conjunction with it. I start by finding a logical pivot and sorting as I find that pivot. I use that pivot as a means to partition my way through the left side and right side of my current array (My pivot is build to take a bias toward picking the middle number; i.e.. the midpoint). With my base case being to check if my array has become to small, so long as it is not I will make a temporary left variable, a temporary right variable that I called shifterLeft and shifterRight; I chose this name because they will shift unlike their static counterpart int left, right. Each of these temp variables will scan their way, swapping along the way, toward the pivot. Once they arrive to a place where they’ve been caught in the middle by the condition “shifterLeft < shifterRight”, we’ve come to a place where they are in the same spot, I use this as an opportunity to swap them for maximum utilization inside of the next partition in the recursive call, while I also swap the pivot with shifterRight to set up my recursion of my left half and my right half of my array. With these conditions in place, after the base case is not met, I will do an insertion sort on my very small array of numbers; This is where insertion sort is best.III. “THE ALGORITHM YOU USED FOR ISORT”My insertion sort algorithm is set up with 2 main for loops, with the assumption that our first element will not be  included because of the set up of checking the current and the previous (the first element will be taken care of by the swaping of j-1 with j so long as it needs swapped). Essentially, the insertion sort goes through every element in the array, at any given index we are checking in that array, check and see if my array at index j-1 is less than the index at j… IF ITS NOT SMALLER, it needs to be, so I swap. This is the essence of my insertion sort. The insertion sort I implemented is also used inside of my quick sort as the else of my base case if statementIV. “THE ALGORITHM USED TO FINDBSTMAXSTR”My findBSTMaxStr function used the insertion sort I implemented as a tool to scan the tree for the max string. With my insertion sort’s skeleton, I use it in conjunction with a global string I named globalStr on line 17 of BST.h. Essentially, I will look at the current nodes string element and compare it to the globalStr, if the element’s string value is higher (I used the #include <string> libraries already maxed out operator overloading, although strcmp could have been used here, I figured I would just utilize what was already available) then swap it out. I continue this as I flow through the tree from left to right, by the end, my updated globalStr will have carried the max value with it throughout the whole time. This produced a globalStr with the max value. I then output this into a custom made file.V. EXTRA THINGS TO CONSIDERThe above are the requirements for this README file. In addition, when you compile my code on Linux (which I developed on a Mac), my makefile is already built, so just type:1. makeThen,2. ./NSProject This should compile and run the code. My code does not run correctly on my MAC, but it will and should run correctly on Linux. 